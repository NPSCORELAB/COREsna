---
title: "Converting Graph Classes"
author: "Brendan Knapp"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The two primary graph classes in R's network analysis ecosystem are `igraph` and `network`. While similar in many ways, the procedures provided do not always overlap. This is a challenge as the `igraph` and `network` classes are not immediately compatible, but analysts often require routines from both.

The common solution comes from the {`intergraph`} package, but the `intergraph::asIgraph()` and `intergraph::asNetwork()` methods have limitations.

There are two issues that {`snatools`} seeks to address with graph conversion via its `as_igraph()` and `as_network()` methods.

1. Enable safe, consistent conversion of all possible graph types, including bipartite graphs
2. Enable strict comparison of an initial graph and its state following conversion.
    + Manually inspecting every aspect of an object _does not replace built-in safety_.
    + Manual inspections should be possible, but be enabled by simple, built-in methods.


```{r, message=FALSE, warning=FALSE}
library(snatools)
library(igraph)
library(network)
```

# Example Graphs

For demonstration, we'll build a pair of relatively complicated `igraph` and `network` objects. First, let's prepare all the data that will be loaded into each graph. The following builds graph, vertex, and edge attributes.

```{r}
set.seed(369)

n_vrt <- 30L
n_edg <- 1000L

graph_attrs <- list(net_chr = "Much Graph. Many Attributes",
                    is_wow = TRUE,
                    net_int = 1L,
                    net_dbl = 3.14)

vertices_df <- data.frame(name = paste0("vrt_", seq_len(n_vrt)),
                          vrt_chr = sample(letters, n_vrt, replace = TRUE),
                          vrt_int = sample(seq.int(100L), n_vrt),
                          vrt_dbl = runif(n_vrt, 0, 100),
                          vrt_lgl = sample(c(TRUE, FALSE), n_vrt, replace = TRUE),
                          stringsAsFactors = FALSE)

edges_df <- data.frame(from = sample(vertices_df$name, n_edg, replace = TRUE),
                       to = sample(vertices_df$name, n_edg, replace = TRUE),
                       edg_chr = sample(letters, n_edg, replace = TRUE),
                       edg_int = sample(seq.int(1000L), n_edg, replace = FALSE),
                       edg_dbl = runif(n_edg, 0, 1000),
                       edg_lgl = sample(c(TRUE, FALSE), n_edg, replace = TRUE),
                       stringsAsFactors = FALSE)
```

## `igraph`

We can then construct an `igraph` object like so.

```{r}
ig_initial <- graph_from_data_frame(edges_df, vertices = vertices_df)
graph_attr(ig_initial) <- graph_attrs
```

```{r}
ig_initial
```

## `network`

Let's modify the data before constructing the `network` object. 

The following changes the name of the vertex attribute that references vertex names from the `igraph` convention (`"name"`) to `network`'s convention (`"vertex.names"`).

```{r}
names(vertices_df)[names(vertices_df) == "name"] <- "vertex.names"
```

We'll also use a `numeric` `matrix` edge list instead of the `"from"` and `"to"` columns of `edges_df`.

```{r}
el <- as_edgelist(ig_initial, names = FALSE)
```

We can then construct the `network` object like so.

```{r}
nw_initial <- as.network.matrix(el, matrix.type = "edgelist", 
                                multiple = TRUE, edge.check = TRUE)

for(g in names(graph_attrs)) {
  set.network.attribute(nw_initial, g, graph_attrs[[g]])
}
for(v in names(vertices_df)) {
  set.vertex.attribute(nw_initial, v, vertices_df[[v]])
}
for(e in names(edges_df)[!names(edges_df) %in% c("from", "to")]) {
  set.edge.attribute(nw_initial, e, edges_df[[e]])
}
```

As with `ig_initial`, we'll assign a graph-level attribute noting its `"original class"`.

The resulting objects are relatively complex and contain attributes from a variety of data types at all levels.

# Simple Conversion

```{r}
as_igraph(nw_initial)

as_network(ig_initial)
```

```{r}
nw_initial %==% as_network(as_igraph(nw_initial))

ig_initial %==% as_igraph(as_network(ig_initial))

nw_initial %==% ig_initial
```



<!-- # Graph Cleaning -->

<!-- In order to confirm that an `igraph` or `network` object can make a round-trip conversion with its internal data remaining intact, we want to standardize its contents. This is the purpose of `clean_graph()`, which is equipped with `clean_graph.igraph()` and `clean_graph.network()` methods. -->

<!-- Here, we clean `ig_initial` to create `ig_clean`. -->

<!-- ```{r} -->
<!-- ig_clean <- clean_graph(ig_initial) -->

<!-- ig_clean -->
<!-- ``` -->

<!-- Similarly, we clean `nw_initial` to create `nw_clean`. -->

<!-- ```{r} -->
<!-- nw_clean <- clean_graph(nw_initial) -->

<!-- nw_clean -->
<!-- ``` -->

<!-- If you don't notice any changes, don't worry. `clean_graph()` is simply ensuring that metadata not strictly required by `igraph` or `network` is present and that attribute names are sorted alphabetically. The changes will usually be subtle if they occur at all. -->

<!-- # Conversion -->

<!-- ## `igraph` to `network` -->

<!-- Once clean, we can safely convert `ig_clean` to a `network` object using `as_network()`. -->

<!-- ```{r} -->
<!-- as_network(ig_clean)  -->
<!-- ``` -->

<!-- ## `network` to `igraph` -->

<!-- Going the other direction, we can convert `nw_clean` to an `igraph` object using `as_igraph()`. -->

<!-- ```{r} -->
<!-- as_igraph(nw_clean) -->
<!-- ``` -->

<!-- ## Testing Conversion -->

<!-- If you're concerned that `as_igraph()` or `as_network()` will mangle your graph's contents, you can test its original state against the result of a round-trip conversion using `identical()`. `identical()` is the __strictest way to compare objects in R__ and only returns `TRUE` if two objects are _exactly_ equal. -->

<!-- Note that there's a _small_ catch with `igraph` objects. By itself, `identical()` will never return `TRUE`. -->

<!-- ```{r} -->
<!-- identical(ig_clean, as_igraph(as_network(ig_clean))) -->
<!-- ``` -->

<!-- This is because `igraph` objects store a pointer that _should not_ be duplicated. We can inspect it like so. -->

<!-- ```{r} -->
<!-- unclass(ig_clean)[[10]] -->
<!-- unclass(as_igraph(as_network(ig_clean)))[[10]] -->
<!-- ``` -->

<!-- In order to test that two `igraph` objects are identical, we need to omit that pointer from the object. -->

<!-- ```{r} -->
<!-- identical(unclass(ig_clean)[1:9], unclass(as_igraph(as_network(ig_clean)))[1:9]) -->
<!-- ``` -->

<!-- To simplify things, {`snatools`} includes the `%==%` infix operator to test that objects are `identical()`. -->

<!-- ```{r} -->
<!-- ig_clean %==% as_igraph(as_network(ig_clean)) -->
<!-- ``` -->

<!-- Underneath the hood, `%==%` uses `identical()` and can test the stict equality of any objects. -->

<!-- ```{r} -->
<!-- snatools:::`%==%.default` -->
<!-- ``` -->


<!-- The exception is for `igraph` objects, for which it is equipped to automatically exclude the pointer that we don't need. -->

<!-- ```{r} -->
<!-- snatools:::`%==%.igraph` -->
<!-- ``` -->

<!-- For `network` objects, you can still use `identical()` if desired. -->

<!-- ```{r} -->
<!-- identical(nw_clean, as_network(as_igraph(nw_clean))) -->
<!-- nw_clean %==% as_network(as_igraph(nw_clean)) -->
<!-- ``` -->

<!-- Now you can be __absolutely certain__ that something did not go wrong when converting between graph classes. -->

<!-- # Bipartite Graphs -->

<!-- ## Example Data -->

<!-- `as_igraph()` and `as_network()` also handle bipartite graphs. The process is _slightly_ more complicated due to the different ways that `igraph` and `network` handle such graphs. -->

<!-- To demonstrate, we'll construct the Southern Women network from scratch using its affiliation matrix. -->

<!-- ```{r} -->
<!-- sw_matrix <- matrix( -->
<!--   c(1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, -->
<!--     1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,  -->
<!--     1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,  -->
<!--     0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -->
<!--     1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, -->
<!--     1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, -->
<!--     0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, -->
<!--     0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, -->
<!--     0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,  -->
<!--     1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, -->
<!--     1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0,  -->
<!--     0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, -->
<!--     0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,  -->
<!--     1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0), -->
<!--   nrow = 14L, ncol = 18L, -->
<!--   dimnames = list( -->
<!--     c("E1", "E2", "E3", "E4", "E5", "E6", "E7", -->
<!--       "E8", "E9", "E10", "E11", "E12", "E13", "E14"), -->
<!--     c("EVELYN", "LAURA", "THERESA", "BRENDA", "CHARLOTTE", "FRANCES", -->
<!--       "ELEANOR", "PEARL", "RUTH", "VERNE", "MYRNA", "KATHERINE",  -->
<!--       "SYLVIA", "NORA", "HELEN", "DOROTHY", "OLIVIA", "FLORA"))) -->

<!-- sw_matrix -->
<!-- ``` -->

<!-- Notice that the "Southern Women" are represented by columns while the events are represented by the rows. -->

<!-- ## Bipartite Graphs in `igraph` -->

<!-- To convert `sw_matrix` to an `igraph` object, we use `graph_from_incidence_matrix()`. We'll also immediately call `clean_graph()`. -->

<!-- ```{r} -->
<!-- southern_women_ig <- sw_matrix %>%  -->
<!--   graph_from_incidence_matrix() %>%  -->
<!--   clean_graph() -->

<!-- southern_women_ig -->
<!-- ``` -->

<!-- `igraph` tracks the two modes via the vertex attribute `"type"`. Here is one of the methods to obtain vertex attributes. -->

<!-- ```{r} -->
<!-- all_vrt_attrs <- as_data_frame(southern_women_ig, "vertices") -->
<!-- ``` -->

<!-- Notice that the "Southern Women" were assigned `TRUE` for their `"type"`. -->

<!-- ```{r} -->
<!-- all_vrt_attrs[all_vrt_attrs$type, ] -->
<!-- ``` -->

<!-- The events were assigned `FALSE`. -->

<!-- ```{r} -->
<!-- all_vrt_attrs[!all_vrt_attrs$type, ] -->
<!-- ``` -->

<!-- This is because of the shape of `sw_matrix`. The `"type"` of vertices coming from columns is assigned `TRUE` while the `"type"` of vertices coming from rows is assigned `FALSE`. -->

<!-- ## Bipartite Graphs in `network` -->

<!-- `network` takes a different approach to handling bipartite graphs by tracking an "actors" mode. -->

<!-- Recall that `nw_clean` is not a bipartite network. -->

<!-- ```{r} -->
<!-- nw_clean -->
<!-- ``` -->

<!-- We an see that it explicilty states that `bipartite = FALSE`. -->

<!-- If a `network` object is bipartite, it's no longer `FALSE`. -->

<!-- ```{r} -->
<!-- southern_women_nw <- as.network.matrix(t(sw_matrix), bipartite = TRUE) %>%  -->
<!--   clean_graph() -->

<!-- southern_women_nw -->
<!-- ``` -->

<!-- It's also not `TRUE`. -->

<!-- `bipartite = 18` refers to the number of vertices belonging to the "actors" mode of the network. In this network, the other vertices are the events. -->

<!-- ## Ambiguity -->

<!-- This difference in bipartite graph handling leaves room for ambiguity when converting from `igraph` to `network`. `as_network()` handles this through its `actor_type` parameter. -->

<!-- `actor_type` refers to the vertices' `"type"` attribute. We can simply provide `TRUE` or `FALSE` to tell `as_network()` which vertices are meant to be actors in the returned `network` object. -->

<!-- For convenience, `actor_type` defaults to `TRUE`. With that in mind, we can think of `"type"` as noting whether a vertex is an "actor" or not, but we need to be careful about creating our objects to reflect this. -->

<!-- ## Putting It All Together -->

<!-- Since our vertices already have the "actor" `"type"` set to `TRUE`, we can convert `southern_women_ig` to a `network` object exactly as we did for `ig_clean`. -->

<!-- ```{r} -->
<!-- as_network(southern_women_ig) -->
<!-- ``` -->

<!-- What does it looks like when our matrix isn't as conveniently designed? -->

<!-- Here's the same network created using `sw_matrix`'s transpose. -->

<!-- ```{r} -->
<!-- swapped_types_ig <- sw_matrix %>% -->
<!--   t() %>%  -->
<!--   graph_from_incidence_matrix() %>%  -->
<!--   clean_graph() -->

<!-- swapped_types_ig -->
<!-- ``` -->

<!-- We can see that the events `"type"` is now `TRUE`, while the `"type"` of the "Southern Women" is `FALSE`. -->

<!-- ```{r} -->
<!-- swapped_vrt_attrs <- as_data_frame(swapped_types_ig, "vertices") -->

<!-- swapped_vrt_attrs[swapped_vrt_attrs$type, ] -->
<!-- ``` -->

<!-- If we don't clarify the ambiguity of `"type"`, the wrong vertices are considered to be the "actors". -->

<!-- ```{r} -->
<!-- as_network(swapped_types_ig) -->
<!-- ``` -->

<!-- By providing `FALSE` as the argument to `actor_type`, we can avoid surprises upon conversion. -->

<!-- ```{r} -->
<!-- as_network(swapped_types_ig, actor_type = FALSE) -->
<!-- ``` -->

<!-- Finally, we can confirm that they all convert properly using `%==%`. -->

<!-- ```{r} -->
<!-- southern_women_ig %==% as_igraph(as_network(southern_women_ig)) -->

<!-- southern_women_nw %==% as_network(as_igraph(southern_women_nw)) -->
<!-- ``` -->



